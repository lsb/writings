{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["browserImageSize","require","downscale","ENDPOINT","ENDPOINT_ALIGNFACES","u64rawfaces","ENDPOINT_RENDER9000","u64latents","ENDPOINT_OPTIMIZE","u64reference","dataURLB64ToServerU64","b64","split","replace","zeroFaceU64","Array","from","length","join","saxpy","a","x","y","Float32Array","v","k","u64ToFloats","u64","u64toArrayBuffer","extendLatents","faceToMorph","sliderIntensity","dropdownMorphChooser","availableFaces","distanceInMorph","f32","getDirection","arrayBufferToU64","buffer","map","f","get","src","dst","fetchNDUTF8Lines","url","err","fetch","response","ok","uint8Stream","streamAsyncIterator","body","stringStream","uint8b64ChunksToStrings","lineStream","stringChunksToLines","line","chunks","previous","eolIndex","indexOf","slice","chunk","TextDecoder","decode","stream","reader","getReader","read","done","value","releaseLock","App","props","state","imageDataURL","u64AlignedFaces","u64Latents","facemathslider","facemathdropdown","faceURLs","Map","loadFaces","r","setState","error","status","faces","faceKey","facePath","set","this","console","log","prefix","Date","now","optimize","pictureFiles","rawImageDataURL","width","height","imageType","push","className","withIcon","buttonText","onChange","u","onDrop","singleImage","String","srcu64Latents","title","onClick","type","min","max","e","target","dstu64Latents","d","optimizeLatch","optimizeAgain","useFacelessUpload","u64f","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.f08d9947.chunk.js","sourcesContent":["import React from 'react';\nimport ImageUploader from 'react-images-upload';\nimport './App.css';\nimport {decode as u64toArrayBuffer, encode as arrayBufferToU64} from 'base64url-arraybuffer';\nconst browserImageSize = require('browser-image-size');\nconst downscale = require('downscale');\n\nconst ENDPOINT = \"https://gpu.leebutterman.com\";\nconst ENDPOINT_ALIGNFACES = (u64rawfaces) => `${ENDPOINT}/alignfaces?u64rawfaces=${u64rawfaces}`;\nconst ENDPOINT_RENDER9000 = (u64latents) => `${ENDPOINT}/render9000?u64latents=${u64latents}`;\nconst ENDPOINT_OPTIMIZE = (u64reference, u64latents) => `${ENDPOINT}/optimize?lr=1&decayrate=0.95&iterations=100&u64reference=${u64reference}&u64latents=${u64latents}`;\n\nconst dataURLB64ToServerU64 = (b64) => b64.split(/,/)[1].replace(/[+]/g,\"-\").replace(/[/]/g,\"_\");\nconst serverU64ToDataURLB64 = (u64) => `data:image/webp;base64,${u64.replace(/[-]/g,'+').replace(/[_]/g,'/')}`;\n\nconst zeroFaceU64 = Array.from({length: 18 * 512 * 4 * 4 / 3}, () => \"A\").join(\"\");\n\nconst saxpy = (a,x,y) => Float32Array.from({length: x.length}, (v,k) => a * x[k] + y[k]);\n\nconst u64ToFloats = (u64) => new Float32Array(u64toArrayBuffer(u64));\nconst floatsToU64 = (f32) => arrayBufferToU64(f32.buffer);\n\nconst extendLatents = (faceToMorph, sliderIntensity, dropdownMorphChooser, availableFaces, distanceInMorph) => floatsToU64(saxpy(distanceInMorph * (sliderIntensity / 10), getDirection(dropdownMorphChooser, availableFaces), u64ToFloats(faceToMorph)));\n\nconst getDirection = (dropdownMorphChooser, availableFaces) => {\n  const [src, dst] = dropdownMorphChooser.split(' ').map(f => availableFaces.get(f));\n  return saxpy(-1, u64ToFloats(src), u64ToFloats(dst));\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {imageDataURL: null, u64AlignedFaces: null, u64Latents: null, facemathslider: 3, facemathdropdown: \"brian trixie2\"};\n    const faceURLs = new Map([\n      [\"brian\", \"./brian-firkus3_01.latents\"],\n      [\"trixie1\", \"./trixie-mattel1_01.latents\"],\n      [\"trixie2\", \"./trixie-mattel-2_01.latents\"],\n      [\"lsb1\", \"./lsb1_01.latents\"],\n      [\"lsb2\", \"./lsb2_01.latents\"],\n      [\"lsb3\", \"./lsb3_01.latents\"],\n      [\"lsb4\", \"./lsb4_01.latents\"],\n      [\"lsb5\", \"./lsb5_01.latents\"],\n    ]);\n    this.loadFaces(faceURLs);\n  }\n  async loadFaces(faceURLs) {\n    const err = (r) => this.setState({error: `loadFaces error ${r.status}`});\n    const faces = new Map([[\"src\", zeroFaceU64],[\"dst\", zeroFaceU64]]);\n    for(let [faceKey, facePath] of faceURLs) {\n      for await (const line of fetchNDUTF8Lines(facePath, err)) {\n        faces.set(faceKey, line);\n      }\n    }\n    this.setState({faces});\n    console.log(faces)\n\n  }\n  async optimize(prefix=\"\") {\n    if(this.state[`${prefix}optimizeLatch`] === true) {\n      this.setState({[`${prefix}optimizeAgain`]: true});\n      return;\n    }\n    console.log(`optimizing ${prefix}`);\n    this.state[`${prefix}optimizeLatch`] = true; // avoid batching locking/latching with setState\n    this.state[`${prefix}optimizeAgain`] = false;\n    this.setState({[`${prefix}lastOptimize`]: Date.now()})\n    const {[`${prefix}u64AlignedFaces`]: u64AlignedFaces, [`${prefix}u64Latents`]: u64Latents} = this.state;\n    if(u64Latents === null || u64AlignedFaces === null || u64AlignedFaces.length === 0) return;\n    const url = ENDPOINT_OPTIMIZE(u64AlignedFaces[0], u64Latents);\n    this.setState({error: null});\n    const err = (r) => this.setState({error: `OPTIMIZE error ${r.status}`});\n    try {\n      for await (const line of fetchNDUTF8Lines(url, err)) {\n        this.setState({[`${prefix}u64Latents`]: line});\n        this.state.faces.set(prefix, line);\n      }\n    } catch (e) {\n      this.setState({error: `OPTIMIZE error run ${e}`});\n    }\n    this.state[`${prefix}optimizeLatch`] = false;\n    this.setState({[`${prefix}lastOptimize`]: Date.now()})\n    if(this.state[`${prefix}optimizeAgain`] === true) this.optimize(prefix);\n  }\n  async onDrop(pictureFiles, [rawImageDataURL], prefix=\"\") {\n    const {width, height} = await browserImageSize(rawImageDataURL);\n    const imageDataURL = await ((width > height) ? downscale(rawImageDataURL, 0, 1024, {imageType: \"jpeg\", \"quality\": 0.7}) : downscale(rawImageDataURL, 1024, 0, {imageType: \"jpeg\", \"quality\": 0.7}));\n    this.setState({[`${prefix}imageDataURL`]: imageDataURL});\n    if(!imageDataURL || !imageDataURL.length || imageDataURL.length === 0) {\n      this.setState({[`${prefix}u64AlignedFaces`]: null, [`${prefix}u64Latents`]: null});\n    } else {\n      const url = ENDPOINT_ALIGNFACES(dataURLB64ToServerU64(imageDataURL));\n      const err = (response) => this.setState({error: `ALIGNFACES error ${response.status}`});\n      const u64AlignedFaces = [];\n      this.setState({[`${prefix}u64AlignedFaces`]: u64AlignedFaces, [`${prefix}u64Latents`]: zeroFaceU64});\n      this.state.faces.set(prefix, zeroFaceU64);\n      for await (const line of fetchNDUTF8Lines(url, err)) {\n        u64AlignedFaces.push(line);\n        this.setState({[`${prefix}alignedFacesCount`]: u64AlignedFaces.length});\n      }\n      if(u64AlignedFaces.length > 0) this.optimize(prefix);\n    }\n  }\n  useFacelessUpload() {\n    this.setState({u64AlignedFaces: [dataURLB64ToServerU64(this.state.imageDataURL)]});\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Face-math selfie makeover</h1>\n        <div className=\"error\">\n          {this.state.error}\n        </div>\n        <div className=\"picker\">\n          <ImageUploader withIcon={true} buttonText=\"Let me take a selfie\" onChange={(f,u) => this.onDrop(f,u)} singleImage={true} />\n        </div>\n        <div className=\"facemath\">\n          {this.state.facemathdropdown !== \"src dst\" ? (<img src={ENDPOINT_RENDER9000(!this.state.faces ? zeroFaceU64 : this.state.faces.get(String(this.state.facemathdropdown).split(\" \")[0], zeroFaceU64))} />) : (<div className=\"iuib\">\n            {!this.state.srcu64Latents ? \"encoded faces show up here\" : (<img src={ENDPOINT_RENDER9000(this.state.srcu64Latents)} title=\"enhance!\" onClick={() => this.optimize(\"src\")} />) }\n            <ImageUploader withIcon={true} buttonText=\"starting point\" onChange={(f,u) => this.onDrop(f,u,\"src\")} singleImage={true} />\n            </div>)}\n          <div className=\"iuib\">\n          <input type=\"range\" min={0} max={11} value={this.state.facemathslider} onChange={e => this.setState({facemathslider: e.target.value * 1})} /> ¬± {this.state.facemathslider * 10}%<br/>\n          <select value={this.state.facemathdropdown} onChange={e => this.setState({facemathdropdown: e.target.value})}>\n            <option value=\"brian trixie2\">¬± Trixie Mattel 2</option>\n            <option value=\"brian trixie1\">¬± Trixie Mattel 1</option>\n            <option value=\"lsb4 lsb5\">¬± Glasses</option>\n            <option value=\"src dst\">¬± choose your own!</option>\n          </select>\n          </div>\n          {this.state.facemathdropdown !== \"src dst\" ? (<img src={ENDPOINT_RENDER9000(!this.state.faces ? zeroFaceU64 : this.state.faces.get(String(this.state.facemathdropdown).split(\" \")[1], zeroFaceU64))} />) : (<div className=\"iuib\">\n            {!this.state.dstu64Latents ? \"encoded faces show up here\" : (<img src={ENDPOINT_RENDER9000(this.state.dstu64Latents)} title=\"enhance!\" onClick={() => this.optimize(\"dst\")} />) }\n            <ImageUploader withIcon={true} buttonText=\"ending point\" onChange={(f,u) => this.onDrop(f,u,\"dst\")} singleImage={true} />\n            </div>)}\n          <hr/>\n          {this.state.u64Latents === null ? \"\" : [-1,-0.5,-0.25,0,0.25,0.5,1].map(d => (<img src={ENDPOINT_RENDER9000(extendLatents(this.state.u64Latents, this.state.facemathslider, this.state.facemathdropdown, this.state.faces, d))} />))}\n        </div>\n        <div>\n          &nbsp; {this.state.optimizeLatch ? \"‚ö°\" : \"\"} {this.state.optimizeAgain ? \"ùÑé\" : \"\"}\n        </div>\n        <div className=\"latentface\">\n          {this.state.u64Latents === null ? \"encoded faces show up here\" : (<img src={ENDPOINT_RENDER9000(this.state.u64Latents)} onClick={() => this.optimize()} />) }\n        </div>\n        <div className=\"alignedfaces\">\n          {this.state.u64AlignedFaces === null\n            ? (this.state.imageDataURL === null ? (<i>aligned faces show up here</i>) : (<i>aligning...</i>))\n            : (this.state.u64AlignedFaces.length === 0 ? (<button onClick={() => this.useFacelessUpload()}>Use this even though it doesn't look like it has a face</button>) : this.state.u64AlignedFaces.map(u64f => (<img src={serverU64ToDataURLB64(u64f)} />)))}\n        </div>\n      </div>\n    )\n  }\n}\n\n\nasync function* fetchNDUTF8Lines(url, err) {\n  const response = await fetch(url);\n  if(!response.ok) {\n    err(response)\n  } else {\n    const uint8Stream = streamAsyncIterator(response.body);\n    const stringStream = uint8b64ChunksToStrings(uint8Stream);\n    const lineStream = stringChunksToLines(stringStream);\n    for await (const line of lineStream) {\n      yield line;\n    }\n  }\n}\nasync function* stringChunksToLines(chunks) {\n  let previous = \"\";\n\n  for await (const chunk of chunks) {\n    previous += chunk;\n    let eolIndex;\n\n    while ((eolIndex = previous.indexOf(\"\\n\")) >= 0) {\n      // this line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      yield line;\n      previous = previous.slice(eolIndex + 1);\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\nasync function* uint8b64ChunksToStrings(chunks) {\n  for await (const chunk of chunks) {\n    yield (new TextDecoder(\"utf-8\").decode(chunk));\n  }\n}\nasync function* streamAsyncIterator(stream) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}